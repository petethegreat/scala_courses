
1.1 programming paradigms

mutation - change some attribute while maintaining identity. For example, could define a polynomial class, then set a certain coefficient to a particular value.

functional programming - avoid mutation - use immutable variables (values)
take something and change it, resulting in something else.
minimise side effects

functional programming
restricted definition - no mutable variables, assignments, or imperative conttrol structures
wider sense - a functional programming language allows the construction of elegant programs that focus on fucntions

functions are first class functions

misc


call by value
def func(a:Int):Int = {...}
function func takes an int, returns an Int. Integer argument a is evaluated when the function is called

call by name
def fun(a: =>Int): Int
function fun takes an integer argment (a). argument a is evaluated when it needs to be.

Not all functions terminate, infinte loops are a thing


Both call by value and call by name will reduce to the same outcome provided
  - the reduced expression consists of pure functions (no state information/side effects?)
  - both evaluations terminate (no infinte loops)

if call by value terminates, then call by name will also
converse is not guarenteed: call by name termination does not imply call by value termination
in call by name, unused arguments are not evaluated
  - could have a function that takes two arguments. The second argument is not used (always)
  - could pass a non-terminating input to the CBN function, which is not used. no big deal
  - call by value will try to evaluate it and get stuck

def loop = loop


def moose(a: Int, b: Int):Int = a

moose(1,loop)
will terminate under call by name but not call by value

scala uses call by value by default, Unless the function arguments are defined with =>

def moose_cbn(a: =>Int, b: =>Int) = {}

conditionals
Boolean operations don't always need to evaluate the right hand operand (short circuit evaluation)


true && e -> e
false && e -> false
true || e -> true
false || e -> e



Things can be defined by name or by value
so 
def x = loop
is a function, it is not evaluated untill it needs to be (call by name)

val x = loop
evaluates to loop (call by value) immediately. this will kill your scala session/repl


test



